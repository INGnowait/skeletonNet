# -*- coding: utf-8 -*-
OUTPUT_ROOT = 'output'
OUTPUT_DIR = '/media/j/data/GDR/core/ske_modeling/output/sken/air_flight/sken_base'
EXP_NAME = ''
DEBUG = False
SEED = -1
CUDNN_BENCHMARK = True
VIS_PERIOD = 0
NUM_SCENE = 11
SKELETON_3D_KEY_NUM=500
NORM_SCALE = 1000 #最大为100000(cm)，转化为m之后就为1000(m),目的是归一化
SKE_DKS = 3  #单像素骨架进行crop之后，会使得骨架变得更细，gt_ske变形，所以将骨架变粗一点，SKE_DKS就是确定膨胀矩阵的大小的
SKELETON='3D'  # 2D为3D postion， 3D 为3D skeleton
INPUT = dict(
    FORMAT='BGR',
    MIN_SIZE_TRAIN=(1000, ),
    MAX_SIZE_TRAIN=1920,
    MIN_SIZE_TRAIN_SAMPLING='choice', # 样本进行增广训练，图片会被缩放到一定的范围用于训练，详情请查看detectron ResizeShortestEdge的介绍
    MIN_SIZE_TEST=1000,
    MAX_SIZE_TEST=1920,
    WITH_DEPTH=False,
    WITH_SKELETON=True,
    AUG_DEPTH=False,
    COLOR_AUG_PROB=0.0,
    COLOR_AUG_TYPE='code',
    COLOR_AUG_CODE=
    'Sequential([Sometimes(0.4, CoarseDropout( p=0.1, size_percent=0.05) ),Sometimes(0.5, GaussianBlur(np.random.rand())),Sometimes(0.5, Add((-20, 20), per_channel=0.3)),Sometimes(0.4, Invert(0.20, per_channel=True)),Sometimes(0.5, Multiply((0.7, 1.4), per_channel=0.8)),Sometimes(0.5, Multiply((0.7, 1.4))),Sometimes(0.5, ContrastNormalization((0.5, 2.0), per_channel=0.3))], random_order=False)',
    COLOR_AUG_SYN_ONLY=False,
    BG_TYPE='VOC_table',
    BG_IMGS_ROOT='/media/j/data/GDR/datasets/VOCdevkit/VOC2012/',
    NUM_BG_IMGS=10000,
    CHANGE_BG_PROB=0.5,
    TRUNCATE_FG=False,
    BG_KEEP_ASPECT_RATIO=True,
    DZI_TYPE='uniform',
    DZI_PAD_SCALE=1.5,
    DZI_SCALE_RATIO=0.25,
    DZI_SHIFT_RATIO=0.25,
    SMOOTH_XYZ=False)
DATASETS = dict(
    TRAIN=('air_flight_train', ),
    TRAIN2=(),
    TRAIN2_RATIO=0.0,
    PROPOSAL_FILES_TRAIN=(),
    PRECOMPUTED_PROPOSAL_TOPK_TRAIN=2000,
    TEST=('air_flight_test', ),
    PROPOSAL_FILES_TEST=(),
    PRECOMPUTED_PROPOSAL_TOPK_TEST=1000,
    DET_FILES_TEST=
    ('/media/j/data/GDR//datasets/BOP_DATASETS/air_flight/test_bboxes/bbox_faster_all_sken.json',
     ),
    DET_TOPK_PER_OBJ=1,
    DET_THR=0.0,
    SYM_OBJS=[]) # sysmetry object has other method to eval
DATALOADER = dict(
    NUM_WORKERS=4,
    ASPECT_RATIO_GROUPING=False,
    SAMPLER_TRAIN='TrainingSampler',
    REPEAT_THRESHOLD=0.0,
    FILTER_EMPTY_ANNOTATIONS=True,
    FILTER_EMPTY_DETS=True,
    FILTER_VISIB_THR=0.0)
SOLVER = dict(
    IMS_PER_BATCH=24,
    TOTAL_EPOCHS=160,
    OPTIMIZER_CFG=dict(type='Ranger', lr=0.0001, weight_decay=0),
    GAMMA=0.1,
    BIAS_LR_FACTOR=1.0,
    LR_SCHEDULER_NAME='flat_and_anneal',
    WARMUP_METHOD='linear',
    WARMUP_FACTOR=0.001,
    WARMUP_ITERS=1000,
    ANNEAL_METHOD='cosine',
    ANNEAL_POINT=0.72,
    POLY_POWER=0.9,
    REL_STEPS=(0.5, 0.75),
    CHECKPOINT_PERIOD=5,
    CHECKPOINT_BY_EPOCH=True,
    MAX_TO_KEEP=5,
    AMP=dict(ENABLED=False),
    WEIGHT_DECAY=0,
    OPTIMIZER_NAME='Ranger',
    BASE_LR=0.0001,
    MOMENTUM=0.9)
TRAIN = dict(PRINT_FREQ=100, VERBOSE=False, VIS=False, VIS_IMG=True)
VAL = dict(
    DATASET_NAME='lm',
    SCRIPT_PATH='lib/pysixd/scripts/eval_pose_results_more.py',
    RESULTS_PATH='',
    TARGETS_FILENAME='lm_test_targets_bb8.json',
    ERROR_TYPES='ad,rete,re,te,proj',
    RENDERER_TYPE='cpp',
    SPLIT='test',
    SPLIT_TYPE='bb8',
    N_TOP=1,
    EVAL_CACHED=False,
    SCORE_ONLY=False,
    EVAL_PRINT_ONLY=False,
    EVAL_PRECISION=False,
    USE_BOP=False)
TEST = dict(
    EVAL_PERIOD=0,
    VIS=True,
    TEST_BBOX_TYPE='est',
    PRECISE_BN=dict(ENABLED=False, NUM_ITER=200),
    AMP_TEST=False,
    USE_PNP=False,
    PNP_TYPE='ransac_pnp')
MODEL = dict(
    DEVICE='cuda',
    WEIGHTS='',
    PIXEL_MEAN=[0.0, 0.0, 0.0],
    PIXEL_STD=[255.0, 255.0, 255.0],
    LOAD_DETS_TEST=True,
    CDPN=dict(
        NAME='SKEN',
        TASK='rot',
        USE_MTL=False,
        BACKBONE=dict(
            PRETRAINED='torchvision://resnet34',
            ARCH='resnet',
            NUM_LAYERS=34,  # 选择resnet 34
            INPUT_CHANNEL=3,
            INPUT_RES=256,
            OUTPUT_RES=64,
            FREEZE=False),
        ROT_HEAD=dict(
            KEY_RADIUS=3,#关键点的半径
            NUM_KP_3D=10,  # 取11个关键点,3dbbox中心点就不检测了
            KP_PRESENT=0,  # 0,1,2分别对应keypoints_3d_c+2d_position中3D坐标的表现形式，分别是xxxxxyyyyyzzzzz,xyzxyzxyzyxzxyz(一个通道预测一个点的一个轴坐标)，以及xyz（一个通道预测所有点的一个轴坐标）
            SKE_THR=0.4,  #ske的阈值
            SKE_DKS=7,  # flux的膨胀系数
            SKE_EKS=9,  # flux的腐蚀系数
            FREEZE=False,  # r_head_net的是否计算梯度
            FREEZE_mask=False,  # 是否冻结mask的loss
            FREEZE_ske=True,  # 是否冻结ske的loss
            FREEZE_kp_3d=True,  # 是否冻结 kp_3d的loss，
            FREEZE_kp_pro=True,  # 是否冻结 kp_pro的loss
            FREEZE_skl_3d_pro=False,  # 是否冻结 skl_3d_pro的loss，
            FREEZE_skl_3d=False,  # 是否冻结 skl_3d的loss
            SKE_FLUX2POINT='end2end',  # {postpro, end2end} 将flux转为point，采用后处理的方法postpro还是卷积核end2end的方法
            SKE_OUTPUT_RES_SCALE=4, #骨架进行loss计算时，上采样到OUTPUT_RES的SKE_OUTPUT_RES_SCALE倍，要是2的倍数，方便于上采样
            ROT_CONCAT=False, #是否将backbone中不同层级的输出输入到rot_head_net中
            XYZ_BIN=64,
            NUM_LAYERS=3,
            NUM_FILTERS=256,
            CONV_KERNEL_SIZE=3,
            NORM='BN',
            NUM_GN_GROUPS=32,
            OUT_CONV_KERNEL_SIZE=1,
            NUM_CLASSES=3,  # object 种类数量
            SKELETON_CLASS_AWARE=False,  #  Rot_head的输出维度是否与NUM_classes相乘
            SKELETON_LOSS_TYPE='MSE', #采用那种loss
            SKELETON_LOSS_MASK_GT='visib', #计算mask_object,mask_visib, mask_trunc中的哪个loss
            SKELETON_LW=1.0, #损失乘以PM_LM,而且他的值只有1和0，就是说要不要这个损失的意思？
            SKELETON_THR_TEST=0.5,
            MASK_CLASS_AWARE=False,
            MASK_LOSS_TYPE='MSE',
            MASK_LOSS_GT='visib',
            MASK_LW=1.0,
            MASK_THR_TEST=0.5,
            KP_PRO_CLASS_AWARE=False,
            KP_PRO_LOSS_TYPE='MSE',
            KP_PRO_LOSS_MASK_GT='visib',
            SKL_3D_PRO_CLASS_AWARE=False,
            SKL_3D_PRO_LOSS_TYPE='MSE',
            SKL_3D_PRO_LOSS_MASK_GT='visib',
            KP_PRO_LW=1.0,
            SKL_3D_PRO_LW=1.0,
            SKL_3D_LW=1.0,
            NUM_REGIONS=100,
            KP_3D_CLASS_AWARE=False,
            KP_3D_LOSS_TYPE='MSE',
            KP_3D_LOSS_MASK_GT='visib',
            SKL_3D_CLASS_AWARE=False,
            SKL_3D_LOSS_TYPE='MSE',
            SKL_3D_LOSS_MASK_GT='visib',
            KP_3D_LW=1.0),
        PNP_NET=dict(
            FREEZE=False,
            R_ONLY=False,
            LR_MULT=1.0,
            PNP_HEAD_CFG=dict(
                type='ConvPnPNet', norm='GN', num_gn_groups=32, drop_prob=0.0),
            WITH_2D_COORD=True,
            KP_3D_CA=False,  # 利用pre_kp_pro的值来优化pre_kp_3d
            SKELETON_ATTENTION='none', #取值mul concat none，attention表示是否先计算softmax，再送去融合, none还表示不使用2D skeleton
            SKELETON_3D_ATTENTION='det',  #none, det 表示是否检测3d skeleton
            SKELETON_2D_DETECTION=False,  # do not detection 2D skeleton and delete 2D skeleton network branch
            MASK_ATTENTION='none', #取值mul concat none，attention表示是否先计算softmax，再送去融合 
            KP_PRO_ATTENTION=False,  # attention表示是否先计算softmax，再送去融合
            KP_3D_ATTENTION=False,  #attention表示是否先计算softmax，再送去融合
            TRANS_WITH_BOX_INFO='none',
            ROT_TYPE='allo_rot6d',
            TRANS_TYPE='centroid_z',
            Z_TYPE='REL',
            NUM_PM_POINTS=3000,
            PM_LOSS_TYPE='L1',
            PM_SMOOTH_L1_BETA=1.0,
            PM_LOSS_SYM=False,
            PM_NORM_BY_EXTENT=True,
            PM_R_ONLY=True,
            PM_DISENTANGLE_T=False, #在计算point matching的损失值的时候使用，用于选择RT损失值的计算方式
            PM_DISENTANGLE_Z=False,#在计算point matching的损失值的时候使用，用于选择RT损失值的计算方式
            PM_T_USE_POINTS=False,
            PM_LW=1.0, # 表示是否计算该loss
            ROT_LOSS_TYPE='angular',
            ROT_LW=0.0,
            CENTROID_LOSS_TYPE='L1',
            CENTROID_LW=1.0,
            Z_LOSS_TYPE='L1',
            Z_LW=1.0,
            TRANS_LOSS_TYPE='L1',
            TRANS_LOSS_DISENTANGLE=True,
            TRANS_LW=0.0,
            BIND_LOSS_TYPE='L1',
            BIND_LW=0.0),
        TRANS_HEAD=dict(
            ENABLED=False,
            FREEZE=True,
            LR_MULT=1.0,
            NUM_LAYERS=3,
            NUM_FILTERS=256,
            NORM='BN',
            NUM_GN_GROUPS=32,
            CONV_KERNEL_SIZE=3,
            OUT_CHANNEL=3,
            TRANS_TYPE='centroid_z',
            Z_TYPE='REL',
            CENTROID_LOSS_TYPE='L1',
            CENTROID_LW=0.0,
            Z_LOSS_TYPE='L1',
            Z_LW=0.0,
            TRANS_LOSS_TYPE='L1',
            TRANS_LW=0.0)),
    KEYPOINT_ON=False,
    LOAD_PROPOSALS=False)
EXP_ID = 'sken_base_test'
RESUME = False
